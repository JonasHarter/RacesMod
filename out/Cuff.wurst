//package Cuff_config
//	@config bool debug = false
//	@config real tic = ANIMATION_PERIOD * 2
//	@config int cuffsPerTic = 2
//endpackage
//
//package Cuff
//	import ArrayList
//	import UnitIndexer
//
//	@configurable bool debug = false
//
//	// Holds all the Cuffs
//	ArrayList<Cuff> cuffs = new ArrayList<Cuff>()
//	
//	// The tic speed of the system
//	@configurable real tic = ANIMATION_PERIOD
//	real runningTic = 1.0
//	
//	// PseudoThreading, Limits the amount of cuffs worked per intervall
//	@configurable int cuffsPerTic = 5
//	integer pointer = 0
//	
//	init
//		if tic > runningTic
//			tic = runningTic
////		CreateTrigger()
////			..registerTimerEvent( tic, true )
////			..addAction( function workerLoop )
//		if(debug)
//			CreateTrigger()
//				..registerTimerEvent(2.0, false)
//				..addAction( function debugCuff )
//			
//	// *****************************************************************
//	
//	function debugCuff()
//		print("##########")
//		print("Cuff Debug Output:")
//		print("#cuffs: " + cuffs.getSize().toString())
//		print("tic: " + tic.toString())
//		print("cuffsPerTic: " + cuffsPerTic.toString())
//		print("throughput: " + ((1.0/tic)*cuffsPerTic).toString() + "CuffsPerSec")
//		print("##########")
//	
//	// *****************************************************************
//	
//	
//	function workerLoop()
//		if cuffs.getSize() == 0
//			return
//		// PseudoThreading
//		for Cuff c in cuffs
//			c.tickTimer()
//		ArrayList<Cuff> currentCuffs = new ArrayList<Cuff>(cuffsPerTic)
//		for int i = 0 to cuffsPerTic - 1
//			currentCuffs.add(cuffs.get(pointer))
//			if pointer == cuffs.getSize() - 1
//				pointer = 0
//			else
//				pointer++
//				
//		group allUnits = GetUnitsInRectAll(GetPlayableMapRect())
//		// Cuff loop
//		for Cuff c in currentCuffs
//			bool timerCheck = c.checkTimer()
//			if timerCheck
//				c.resetTimer()
//			// All unit loop
//			for unit u in allUnits
//				int lastLvl = c.loadLevel(u)
//				int curLvl = c.getLevel(u)
//				if curLvl != 0
//					if lastLvl == 0
//						c.start(u, curLvl)
//						c.storeLevel(u, curLvl)
//					else if lastLvl != curLvl
//						c.finish(u, lastLvl)
//						c.storeLevel(u, curLvl)
//						c.start(u, curLvl)
//					else if timerCheck
//						c.running(u, curLvl)
//				else if lastLvl > 0
//					c.finish(u, lastLvl)
//					c.storeLevel(u, 0)
//		allUnits.destr()
//		destroy currentCuffs
//
//	// *****************************************************************
//	
//	public class Cuff
//
//		// If both condition and buffs are in use, conditions will be interpreted as boolean
//		// If both are false, it will always run
//		private bool useBuffs = true
//		private bool useCondition = false
//		// How all abilities will be added
//		// 0: All added
//		// 1: All added and set to the level
//		// 2: Each ability stands for one level
//		private int abilityMode = 0
//		private ArrayList<integer> buffs = new ArrayList<integer>()
//		private ArrayList<integer> abilities = new ArrayList<integer>()
//		// Tracks applied units and the cuff level
//		private integer array[JASS_MAX_ARRAY_SIZE] level
//		
//		construct()
//			this.register()
//					
//		construct(bool useBuffs, bool useCondition, int abilityMode)
//			this.useBuffs = useBuffs
//			this.useCondition = useCondition
//			if abilityMode < 0 or abilityMode > 2
//				print("Unknown Ability Level")
//			else
//				this.abilityMode = abilityMode
//			this.register()
//		
//		// The unique id of the hash
//		private int hashID
//		function getID() returns int
//			return hashID
//		
//		private function register()
//			cuffs.add(this)
//			
//		// Stores the level off the Cuff on the unit under its ID
//		function storeLevel(unit u, int value)
//			level[u.getIndex()] = value
//			
//		function loadLevel(unit u) returns int
//			return level[u.getIndex()]
//			
//		// Checks wether a unit has the buff or satisfies the condition
//        // Alternative/additional condition
//		function condition(unit target) returns integer
//			return 0
//		
//		function addBuff(int b)
//			buffs.add(b)
//			
//		function addAbility(int a)
//			abilities.add(a)
//			
//		function getLevel(unit u) returns int
//			int cond = 0
//			int buffs = 0
//			
//			// Condition
//			if this.useCondition
//				cond = this.condition(u)
//
//			// Bound Buffs
//			if this.useBuffs
//				int i = 0
//				for int b in this.buffs
//					i++
//					if u.hasAbility(b)
//						buffs = i
//					
//            // Return the correct value
//			if useCondition and not(useBuffs)
//				return cond
//			else if useBuffs and not(useCondition)
//				return buffs
//			else if useCondition and useBuffs and cond > 0
//				return buffs
//			else if not(useBuffs) and not(useCondition)
//				return 1
//			else
//				return 0
//        
//        // The timer functions
//		private real ticSum = 0.0
//		function checkTimer() returns bool
//			return ticSum >= runningTic
//		function tickTimer()
//			ticSum += tic
//		function resetTimer()
//			ticSum -= runningTic
//			
//        // Runs if the buff is new on the unit
//		function start(unit target, integer level)
//			if abilities.getSize() > 0
//				if abilityMode == 0
//					for int a in abilities
//						target.addAbility(a)
//				else if abilityMode == 1
//					for int a in abilities
//						target.addAbility(a)
//						target.setAbilityLevel(a, level)
//				else if abilityMode == 2
//					target.addAbility(abilities.get(level - 1))
//			apply(target, level)
//				
//		function apply(unit target, integer level)
//			skip
//		
//        // Runs each interval
//		function running(unit target, integer level)
//			skip
//
//        // Runs if the buff is gone
//		function finish(unit target, integer level)
//			if abilities.getSize() != 0
//				for int a in abilities
//					target.removeAbility(a)
//			clean(target, level)
//			
//		function clean(unit target, integer level)
//			skip
//	
//endpackage